{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "title": "GetFlowResponse",
  "type": "object",
  "properties": {
    "flow": {
      "description": "The flow that was searched for.",
      "anyOf": [
        {
          "$ref": "#/definitions/Flow"
        },
        {
          "type": "null"
        }
      ]
    }
  },
  "additionalProperties": false,
  "definitions": {
    "Asset": {
      "type": "object",
      "required": [
        "amount",
        "info"
      ],
      "properties": {
        "amount": {
          "$ref": "#/definitions/Uint128"
        },
        "info": {
          "$ref": "#/definitions/AssetInfo"
        }
      },
      "additionalProperties": false
    },
    "AssetInfo": {
      "description": "AssetInfo contract_addr is usually passed from the cw20 hook so we can trust the contract_addr is properly validated.",
      "oneOf": [
        {
          "type": "object",
          "required": [
            "token"
          ],
          "properties": {
            "token": {
              "type": "object",
              "required": [
                "contract_addr"
              ],
              "properties": {
                "contract_addr": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        },
        {
          "type": "object",
          "required": [
            "native_token"
          ],
          "properties": {
            "native_token": {
              "type": "object",
              "required": [
                "denom"
              ],
              "properties": {
                "denom": {
                  "type": "string"
                }
              },
              "additionalProperties": false
            }
          },
          "additionalProperties": false
        }
      ]
    },
    "Binary": {
      "description": "Binary is a wrapper around Vec<u8> to add base64 de/serialization with serde. It also adds some helper methods to help encode inline.\n\nThis is only needed as serde-json-{core,wasm} has a horrible encoding for Vec<u8>. See also <https://github.com/CosmWasm/cosmwasm/blob/main/docs/MESSAGE_TYPES.md>.",
      "type": "string"
    },
    "CanonicalAddr": {
      "description": "A blockchain address in its binary form.\n\nThe specific implementation is up to the underlying chain and CosmWasm as well as contracts should not make assumptions on that data. In Ethereum for example, an `Addr` would contain a user visible address like 0x14d3cc818735723ab86eaf9502376e847a64ddad and the corresponding `CanonicalAddr` would store the 20 bytes 0x14, 0xD3, ..., 0xAD. In Cosmos, the bech32 format is used for `Addr`s and the `CanonicalAddr` holds the encoded bech32 data without the checksum. Typical sizes are 20 bytes for externally owned addresses and 32 bytes for module addresses (such as x/wasm contract addresses). That being said, a chain might decide to use any size other than 20 or 32 bytes.\n\nThe safe way to obtain a valid `CanonicalAddr` is using `Api::addr_canonicalize`. In addition to that there are many unsafe ways to convert any binary data into an instance. So the type shoud be treated as a marker to express the intended data type, not as a validity guarantee of any sort.",
      "allOf": [
        {
          "$ref": "#/definitions/Binary"
        }
      ]
    },
    "Curve": {
      "description": "The type of distribution curve to exist.",
      "oneOf": [
        {
          "description": "A linear curve that releases assets as we approach the end of the flow period.",
          "type": "string",
          "enum": [
            "linear"
          ]
        }
      ]
    },
    "Flow": {
      "description": "Represents a flow.",
      "type": "object",
      "required": [
        "claimed_amount",
        "curve",
        "end_timestamp",
        "flow_asset",
        "flow_creator",
        "flow_id",
        "start_timestamp"
      ],
      "properties": {
        "claimed_amount": {
          "description": "The amount of the `flow_asset` that has been claimed so far.",
          "allOf": [
            {
              "$ref": "#/definitions/Uint128"
            }
          ]
        },
        "curve": {
          "description": "The type of curve the flow has.",
          "allOf": [
            {
              "$ref": "#/definitions/Curve"
            }
          ]
        },
        "end_timestamp": {
          "description": "The timestamp (in seconds block time) for when the flow will end.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "flow_asset": {
          "description": "The asset the flow was created to distribute.",
          "allOf": [
            {
              "$ref": "#/definitions/Asset"
            }
          ]
        },
        "flow_creator": {
          "description": "The account which opened the flow and can manage it.",
          "allOf": [
            {
              "$ref": "#/definitions/CanonicalAddr"
            }
          ]
        },
        "flow_id": {
          "description": "A unique identifier of the flow.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        },
        "start_timestamp": {
          "description": "The timestamp (in seconds block time) for when the flow began.",
          "type": "integer",
          "format": "uint64",
          "minimum": 0.0
        }
      },
      "additionalProperties": false
    },
    "Uint128": {
      "description": "A thin wrapper around u128 that is using strings for JSON encoding/decoding, such that the full u128 range can be used for clients that convert JSON numbers to floats, like JavaScript and jq.\n\n# Examples\n\nUse `from` to create instances of this and `u128` to get the value out:\n\n``` # use cosmwasm_std::Uint128; let a = Uint128::from(123u128); assert_eq!(a.u128(), 123);\n\nlet b = Uint128::from(42u64); assert_eq!(b.u128(), 42);\n\nlet c = Uint128::from(70u32); assert_eq!(c.u128(), 70); ```",
      "type": "string"
    }
  }
}
